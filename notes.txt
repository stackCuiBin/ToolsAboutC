第1课 深入浅出处理器-上
1，处理器：微控制器 VS 微处理器
	微控制器
		CPU + 片内内存 + 片内外设
	微处理器
		CPU
注意：
	为控制器具有成本低，功耗低等优点，常用于嵌入式系统设计
	对于软件工程师而言，微控制器和微处理器没有任何区别

2，寄存器的分类
	CPU寄存器
		专用指令执行，数据运算，变量处理，参数传递
	外设寄存器
		用于控制外设的行为和工作方式
		寄存器值的配置需要根据芯片手册完成

3，处理器中的关键寄存器
	PC-程序计数器(指令指针IP)
		每执行一条指令，PC中的值就会发生变化
		PC始终保存下一条CPU要执行的指令地址
	SP-栈指针(Stack Pointer)
		始终指向栈空间的顶端，实现LIFO特性
		保存中断断点，保存函数调用的返回点，保存CPU现场数据，等
		
4，处理器的IO操作
	处理器与外设之间的数据通信通过IO操作完成
	内存映射IO空间
		外设通过精密的硬件连接映射到处理器的地址空间
		通过地址访问的方式与外设进行通信
	独立IO空间
		独立于地址空间，无法通过地址访问外设
		使用专用指令与外设进行通信
	操作外设的基本方式
		通过IO端口配置控制寄存器
		通过IO端口读取数据寄存器
(从软件工程师的角度来看，只需要对不同的IO端口读写就可以操作外设；读写IO端口
时候的具体值和意义需要查询具体的硬件手册)

5，处理器的启动过程简介
	处理器上电后，PC寄存器固化了一个默认值
	PC默认值用于决定第一条执行指令
	第一条执行指令隶属于启动程序
	
6，启动程序(Bootloader)
	系统上电后运行的第一个程序(not OS)
	根据运行阶段，体积和功能的不同分为三个部分
		BL0-固化于硬件中，用于初始化硬件，加载并运行BL1
		BL1-存储于外部存储设备中，用于初始化主存，加载并运行BL2
		BL2-存储于外部存储设备中，用于引导操作系统执行
		
第2课 深入浅出处理器-中
1，中断的概念和意义
	中断是一种处理器与外设进行通信的机制
	用于“通知”处理器外部有“重要事件”发生
	一般情况下，中断需要被处理器响应

2，中断服务程序(ISR)
	从外设中读取中断状态寄存器的值，以便了解中断类型
	根据中断类型具体设计处理逻辑
	清除外设状态寄存器中的中断标志位
	清除处理器中的中断标志位
	
3，软件工程师眼中的中断服务程序
	不能有返回值，不能有参数传递
	必须短小而高效，避免浮点运算
	
4，中断的意义
	应用程序不必关心中断的发生与处理
	中断服务程序不必关心应用程序的执行状态
	中断是“上层应用”与“底层代码”的“分割界限”

5，中断的类型
	硬中断
		通过处理器中断信号线产生的中断
	软中断
		通过非法指令或者特殊指令触发的中断

6，中断的优先级
	多个中断同时出现时，处理器先响应高优先级的中断
	低优先级中断的ISR执行时，可以被高优先级中断再次打断
	ISR比APP Code拥有更高的执行优先级
	
7，中断的应用-程序断点
	断点指的是调试工具用于暂停代码执行的指令位置
	断点的实现原理为处理器的中断支持
		软件断点：利用非法指令异常产生中断实现
		硬件断点：利用中断寄存器的特性产生中断实现
		
8，程序断点的实现原理
	获取原程序指定行对应的代码地址
	把代码地址中的指令替换为中断触发指令
	在中断服务程序中将控制权交给调试程序
	调试程序读写源程序上下文信息
	调试程序将代码地址中的指令还原
	原程序从断点处继续向下执行
	
9，一个工程产品案例的剖析
	背景
		嵌入式实时系统对时序的要求比较严格
		各个线程的执行有相对严格的时间要求
	痛点
		断点调试在嵌入式实时系统中不适用
	
	常规解决方案-日志调试法
		在代码中的“关键位置”添加打印语句
		打印语句尽可能详细的打印上下文信息(函数名，局部变量，等)
		当系统出现问题时，查看日志文件，分析问题
	日志调试法存在的问题
		不易维护
			打印语句分散于产品代码的各个角落
		影响效率
			过多的打印语句意味着过多的IO操作，影响产品的整体执行效率
		分析困难
			当日志输出数量非常多的时候，很难精确定位问题
			也许只有添加打印语句的工程师看得懂日志输出
	一个想法
		同时结合日志调试法和断点调试法的优点，使得实时系统调试时，能够任意
		查看指定代码行上下文的信息；并且不增加打印语句，不暂停执行。
	解决方案
		获取原程序指定行对应的代码地址
		把代码地址中的指令替换为中断触发指令
		在中断服务程序中抓取全局信息和栈信息
		抓取的信息发送回调试程序并解析并输出
		
第3课 深入浅出处理器-下
1，内存管理单元(MMU)
	现代处理器中对内存进行高效管理的功能单元
	操作系统利用内存管理单元能够实现
		虚拟内存
		内存保护

2，经常被遗忘的事实
	应用程序开发时，面对的内存为虚拟内存
	虚拟内存模式下使用的内存地址为虚拟地址
	每一个进程拥有独立私有的虚拟地址空间
	(虚拟内存与实际物理内存无关，是一个假想的足够大的内存)
	
3，虚拟内存的意义
	虚拟内存能够支持多个大内存需求量的进程同时运行于较小的物理内存中。

4，虚拟内存的机制
	虚拟内存需要重新映射到物理内存
	虚拟地址映射到物理内存中的实地址
	每次只有进程的少量代码在物理内存中运行
	大部分进程代码位于存储器中
	
5，页式内存管理
	页时内存单位，指一定数量的内存(如：4K)
	虚拟内存和物理内存以页为单位管理
	进程的活动页被载入内存时，记录页地址的映射关系
	
	页式管理法将内存分为两个部分(p,d)
		p-地址高位，页面号
		d-地址低位，页内偏移量
	
第4课 深入浅出处理器-续
1，一个工艺上的问题
	处理器和内存所使用的半导体器件工艺不同
	工艺的差异导致了处理器与内存的速度差异
	数据处理时，处理器总是需要等待内存

2，程序访问的局部性
	短时间内，处理器访问的存储空间是一个很小的范围
		时间局部性
			某个存储单元在短时间内很可能被再次访问
		空间局部性
			某个存储单元的邻近单元在短时间内也被访问
			
3，高速缓冲存储器的引入(cache)
	cache是一种小容量高速存储器
	cache的存取速度与处理器的运算速度几乎同量级
	cache在现代计算机系统中直接内置于处理器芯片中
	
4，cache解决方案
	在处理器和内存之间设置cache
	把内存中被频繁访问的指令和数据复制到cache中
	大多数情况下，处理器能直接从cache中取得指令和数据

问题
	内存和cache之间如何映射？

5，直接映射法
	将cache和内存分成相同固定大小的块(如：512byte/块)
	内存中的每一块在cache中有固定的映射位置
	映射公式为
		POScache = 内存块号 % cache总块数
		
						0
				  |---->1
	flag0  0	  |		2
	flag1  1------		3
	flag2  2	  |		4
	flag3  3	  |---->5
	
	 cache			内存
	 特点：任意一个内存地址都能映射到cache中的一个固定位置
	 
	 内存地址划分
	 	标记    cache块号    块内地址
	 	t位       c位          b位
	 映射原理
	 	根据访问地址的中间c位找到cache中的对应块
	 	比较地址的高t位是否和cache flag相同
	 		相同：直接读取数据
	 		不同：从内存中复制块内容(更新cache的flag)
	 		
	直接映射法的特点
		优点：映射过程简单，所需耗时短
		缺点：当短时间内访问的地址有同余冲突时，会造成缓存失效

第5课 嵌入式C语言编译器
1，GCC和gcc有什么不同
	GCC( GNU Compiler Collection)
		GNU编译器集合，包含众多语言的编译器
		C，C++, Java, D, ...
	gcc
		特指GCC中的C语言编译器
		
2，GCC VS 嵌入式
	多数嵌入式操作系统都基于GCC进行源码编译
		Linux，VxWorks，Android，...
	实际开发中的使用
		内核开发：gcc
		应用开发：gcc/g++/gdc

3，什么是交叉编译？
	背景
		嵌入式设备往往资源受限
		不肯能在嵌入式上直接对处理器进行编程
	解决方案
		在开发主机(PC)上对源码进行编译
		最终生成目标主机(嵌入式设备)的可执行程序

4，gcc是如何进行交叉编译的？
	配置目标主机的编译工具链(如：arm-linux)
	配置工具链的具体版本
		根据具体的目标代码选择相应的工具链版本
		正确使用关于体系结构的特殊编译选项
		
5，初识编译器
	编译器：预处理器，编译器，汇编器，链接器
	file.c
			预处理器 -> file.i -> 编译器 -> file.s -> 汇编器 -> file.o
	file.h
	
6，如何理解"多语言混合开发"?
	开发方式一
	X语言
	Y语言 -> 目标平台汇编语言 -> 目标平台汇编器 -> 可执行程序
	Z语言
	
	开发方式二
	X语言 -> x.dll
	Y语言 -> y.a    目标平台链接器 -> 可执行程序
	Z语言 -> z.dll
	
	开发方式三
	X语言 -> x.exe
	Y语言 -> y.exe  进程间通信协议 -> 可执行程序
	Z语言 -> z.exe
	
7，gcc关键编译选项一
	预处理指令
		gcc -E file.c -o file.i
	编译指令
		gcc -S file.i -o file.s
	汇编指令
		gcc -c file.s -o file.o
	
	gcc关键编译选项二
	生成映射文件
		gcc -Wl,-Map=test.map file.c
	宏定义
		gcc -D'TEST="test"' file.c
	获取系统头文件路径
		gcc -v file.c
		
	gcc关键编译选项三
	生成依赖关系
		获取目标的完整依赖关系
			gcc -M test.c
		获取目标的部分依赖关系
			gcc -MM test.c
			
	gcc关键编译选项四
	指定库文件及库文件搜索路径
		-L选项：指定库文件的搜索路径
		-l选项：指定库文件
			gcc test.c -L. -lfunc
	
			

		
