第1课 深入浅出处理器-上
1，处理器：微控制器 VS 微处理器
	微控制器
		CPU + 片内内存 + 片内外设
	微处理器
		CPU
注意：
	为控制器具有成本低，功耗低等优点，常用于嵌入式系统设计
	对于软件工程师而言，微控制器和微处理器没有任何区别

2，寄存器的分类
	CPU寄存器
		专用指令执行，数据运算，变量处理，参数传递
	外设寄存器
		用于控制外设的行为和工作方式
		寄存器值的配置需要根据芯片手册完成

3，处理器中的关键寄存器
	PC-程序计数器(指令指针IP)
		每执行一条指令，PC中的值就会发生变化
		PC始终保存下一条CPU要执行的指令地址
	SP-栈指针(Stack Pointer)
		始终指向栈空间的顶端，实现LIFO特性
		保存中断断点，保存函数调用的返回点，保存CPU现场数据，等
		
4，处理器的IO操作
	处理器与外设之间的数据通信通过IO操作完成
	内存映射IO空间
		外设通过精密的硬件连接映射到处理器的地址空间
		通过地址访问的方式与外设进行通信
	独立IO空间
		独立于地址空间，无法通过地址访问外设
		使用专用指令与外设进行通信
	操作外设的基本方式
		通过IO端口配置控制寄存器
		通过IO端口读取数据寄存器
(从软件工程师的角度来看，只需要对不同的IO端口读写就可以操作外设；读写IO端口
时候的具体值和意义需要查询具体的硬件手册)

5，处理器的启动过程简介
	处理器上电后，PC寄存器固化了一个默认值
	PC默认值用于决定第一条执行指令
	第一条执行指令隶属于启动程序
	
6，启动程序(Bootloader)
	系统上电后运行的第一个程序(not OS)
	根据运行阶段，体积和功能的不同分为三个部分
		BL0-固化于硬件中，用于初始化硬件，加载并运行BL1
		BL1-存储于外部存储设备中，用于初始化主存，加载并运行BL2
		BL2-存储于外部存储设备中，用于引导操作系统执行
		
第2课 深入浅出处理器-中
1，中断的概念和意义
	中断是一种处理器与外设进行通信的机制
	用于“通知”处理器外部有“重要事件”发生
	一般情况下，中断需要被处理器响应

2，中断服务程序(ISR)
	从外设中读取中断状态寄存器的值，以便了解中断类型
	根据中断类型具体设计处理逻辑
	清除外设状态寄存器中的中断标志位
	清除处理器中的中断标志位
	
3，软件工程师眼中的中断服务程序
	不能有返回值，不能有参数传递
	必须短小而高效，避免浮点运算
	
4，中断的意义
	应用程序不必关心中断的发生与处理
	中断服务程序不必关心应用程序的执行状态
	中断是“上层应用”与“底层代码”的“分割界限”

5，中断的类型
	硬中断
		通过处理器中断信号线产生的中断
	软中断
		通过非法指令或者特殊指令触发的中断

6，中断的优先级
	多个中断同时出现时，处理器先响应高优先级的中断
	低优先级中断的ISR执行时，可以被高优先级中断再次打断
	ISR比APP Code拥有更高的执行优先级
	
7，中断的应用-程序断点
	断点指的是调试工具用于暂停代码执行的指令位置
	断点的实现原理为处理器的中断支持
		软件断点：利用非法指令异常产生中断实现
		硬件断点：利用中断寄存器的特性产生中断实现
		
8，程序断点的实现原理
	获取原程序指定行对应的代码地址
	把代码地址中的指令替换为中断触发指令
	在中断服务程序中将控制权交给调试程序
	调试程序读写源程序上下文信息
	调试程序将代码地址中的指令还原
	原程序从断点处继续向下执行
	
9，一个工程产品案例的剖析
	背景
		嵌入式实时系统对时序的要求比较严格
		各个线程的执行有相对严格的时间要求
	痛点
		断点调试在嵌入式实时系统中不适用
	
	常规解决方案-日志调试法
		在代码中的“关键位置”添加打印语句
		打印语句尽可能详细的打印上下文信息(函数名，局部变量，等)
		当系统出现问题时，查看日志文件，分析问题
	日志调试法存在的问题
		不易维护
			打印语句分散于产品代码的各个角落
		影响效率
			过多的打印语句意味着过多的IO操作，影响产品的整体执行效率
		分析困难
			当日志输出数量非常多的时候，很难精确定位问题
			也许只有添加打印语句的工程师看得懂日志输出
	一个想法
		同时结合日志调试法和断点调试法的优点，使得实时系统调试时，能够任意
		查看指定代码行上下文的信息；并且不增加打印语句，不暂停执行。
	解决方案
		获取原程序指定行对应的代码地址
		把代码地址中的指令替换为中断触发指令
		在中断服务程序中抓取全局信息和栈信息
		抓取的信息发送回调试程序并解析并输出
		
第3课 深入浅出处理器-下
1，内存管理单元(MMU)
	现代处理器中对内存进行高效管理的功能单元
	操作系统利用内存管理单元能够实现
		虚拟内存
		内存保护

2，经常被遗忘的事实
	应用程序开发时，面对的内存为虚拟内存
	虚拟内存模式下使用的内存地址为虚拟地址
	每一个进程拥有独立私有的虚拟地址空间
	(虚拟内存与实际物理内存无关，是一个假想的足够大的内存)
	
3，虚拟内存的意义
	虚拟内存能够支持多个大内存需求量的进程同时运行于较小的物理内存中。

4，虚拟内存的机制
	虚拟内存需要重新映射到物理内存
	虚拟地址映射到物理内存中的实地址
	每次只有进程的少量代码在物理内存中运行
	大部分进程代码位于存储器中
	
5，页式内存管理
	页时内存单位，指一定数量的内存(如：4K)
	虚拟内存和物理内存以页为单位管理
	进程的活动页被载入内存时，记录页地址的映射关系
	
	页式管理法将内存分为两个部分(p,d)
		p-地址高位，页面号
		d-地址低位，页内偏移量
	
第4课 深入浅出处理器-续
1，一个工艺上的问题
	处理器和内存所使用的半导体器件工艺不同
	工艺的差异导致了处理器与内存的速度差异
	数据处理时，处理器总是需要等待内存

2，程序访问的局部性
	短时间内，处理器访问的存储空间是一个很小的范围
		时间局部性
			某个存储单元在短时间内很可能被再次访问
		空间局部性
			某个存储单元的邻近单元在短时间内也被访问
			
3，高速缓冲存储器的引入(cache)
	cache是一种小容量高速存储器
	cache的存取速度与处理器的运算速度几乎同量级
	cache在现代计算机系统中直接内置于处理器芯片中
	
4，cache解决方案
	在处理器和内存之间设置cache
	把内存中被频繁访问的指令和数据复制到cache中
	大多数情况下，处理器能直接从cache中取得指令和数据

问题
	内存和cache之间如何映射？

5，直接映射法
	将cache和内存分成相同固定大小的块(如：512byte/块)
	内存中的每一块在cache中有固定的映射位置
	映射公式为
		POScache = 内存块号 % cache总块数
		
						0
				  |---->1
	flag0  0	  |		2
	flag1  1------		3
	flag2  2	  |		4
	flag3  3	  |---->5
	
	 cache			内存
	 特点：任意一个内存地址都能映射到cache中的一个固定位置
	 
	 内存地址划分
	 	标记    cache块号    块内地址
	 	t位       c位          b位
	 映射原理
	 	根据访问地址的中间c位找到cache中的对应块
	 	比较地址的高t位是否和cache flag相同
	 		相同：直接读取数据
	 		不同：从内存中复制块内容(更新cache的flag)
	 		
	直接映射法的特点
		优点：映射过程简单，所需耗时短
		缺点：当短时间内访问的地址有同余冲突时，会造成缓存失效

第5课 嵌入式C语言编译器
1，GCC和gcc有什么不同
	GCC( GNU Compiler Collection)
		GNU编译器集合，包含众多语言的编译器
		C，C++, Java, D, ...
	gcc
		特指GCC中的C语言编译器
		
2，GCC VS 嵌入式
	多数嵌入式操作系统都基于GCC进行源码编译
		Linux，VxWorks，Android，...
	实际开发中的使用
		内核开发：gcc
		应用开发：gcc/g++/gdc

3，什么是交叉编译？
	背景
		嵌入式设备往往资源受限
		不肯能在嵌入式上直接对处理器进行编程
	解决方案
		在开发主机(PC)上对源码进行编译
		最终生成目标主机(嵌入式设备)的可执行程序

4，gcc是如何进行交叉编译的？
	配置目标主机的编译工具链(如：arm-linux)
	配置工具链的具体版本
		根据具体的目标代码选择相应的工具链版本
		正确使用关于体系结构的特殊编译选项
		
5，初识编译器
	编译器：预处理器，编译器，汇编器，链接器
	file.c
			预处理器 -> file.i -> 编译器 -> file.s -> 汇编器 -> file.o
	file.h
	
6，如何理解"多语言混合开发"?
	开发方式一
	X语言
	Y语言 -> 目标平台汇编语言 -> 目标平台汇编器 -> 可执行程序
	Z语言
	
	开发方式二
	X语言 -> x.dll
	Y语言 -> y.a    目标平台链接器 -> 可执行程序
	Z语言 -> z.dll
	
	开发方式三
	X语言 -> x.exe
	Y语言 -> y.exe  进程间通信协议 -> 可执行程序
	Z语言 -> z.exe
	
7，gcc关键编译选项一
	预处理指令
		gcc -E file.c -o file.i
	编译指令
		gcc -S file.i -o file.s
	汇编指令
		gcc -c file.s -o file.o
	
	gcc关键编译选项二
	生成映射文件
		gcc -Wl,-Map=test.map file.c
	宏定义
		gcc -D'TEST="test"' file.c
	获取系统头文件路径
		gcc -v file.c
		
	gcc关键编译选项三
	生成依赖关系
		获取目标的完整依赖关系
			gcc -M test.c
		获取目标的部分依赖关系
			gcc -MM test.c
			
	gcc关键编译选项四
	指定库文件及库文件搜索路径
		-L选项：指定库文件的搜索路径
		-l选项：指定库文件
			gcc test.c -L. -lfunc
	
第6课
1，什么是开发环境？
	构建环境
		代码编写，程序编译，版本控制
	调试环境
		用于定位问题的辅助工具集
	测试环境
		用于验证目标程序是否满足用户的显性需求和隐性需求

2，GNU为GCC编译器提供了配套的辅助工具集(binutils)
	工具名		功能简介
	addr2line	将代码地址转换为对应的程序行号
	strip		剔除可执行程序中的调试信息
	ar			将目标文件打包成为静态库
	nm			列出目标文件中的符号及对应地址
	objdump		查看程序段信息及反汇编
	size		查看目标文件中的段大小
	strings		查看目标文件中的字符串
	
	addr2line	
		将指定地址转换为对应的文件名和行号
		常用于分析和定位内存访问错误的问题
	示例：定位0地址访问
		开启core dump选项
			ulimit -c unlimited
		运行程序，并生成奔溃时的core文件
			执行导致程序崩溃的测试用例
		读取core文件，获取IP寄存器的值(0x08048000)
			dmesg core
		使用addr2line定位代码行
			addr2line 0x08048000 -f -e test.out
			
	strip
		剔除程序文件中的调试信息，减少目标程序的大小
		一般在程序发布前都需要将调试信息剔除
		过多的调试信息可能影响程序的执行效率
		strip test.out

注意事项
	几乎所有的调试辅助工具都依赖于目标文件中的调试信息
	调试信息的运用能够快速定位问题
	使用gcc编译程序时使用-g选项生成调试信息
	发布程序时再考虑是否使用strip剔除调试信息
	
	ar
		打包目标文件
			ar crs libname.a x.o y.o
		解压目标文件
			ar x libname.a
			
	nm
		列出目标文件中的标识符(变量名，函数名)
		输出结果由三部分组成：{地址，段，标识符}
		示例： 08048430        T            func
		  标识符对应的地址   位于代码段   标识符的名字
	段标识说明
	A		地址值子啊链接过程中不会发生改变
	B或b		标识符位于未初始化数据段(.bss)
	C		未定义存储段的标识符，连接时决定段位置
	D或d		标识符位于数据段(.data)
	N		调试专用标识符
	R或r		标识符位于只读存储区(.rdata)
	T或t		标识符位于代码段(.text)
	U		未定义的标识符
	
	objdump
		反汇编目标文件，查看汇编到源码的映射
			objdump -d func.o
			objdump -S func.o
		查看目标文件中的详细段信息
			objdump -h test.out
	objdump -h的输出说明
		idx			段下标
		Name		段标识符(名字)
		Size		段所占空间的大小
		VMA			段起始地址的虚存地址
		LMA			段所在存储空间中的加载地址
		File off	段在目标文件中的相对位置
		Algn		段的边界对齐字节数
		
	size
		获取目标文件中的所有段大小
			size test.out
	
	strings
		获取目标文件中的所有字符串常量
			strings test.out
	
第7课 揭开链接器的面纱-上
1，链接器的意义
	链接器的主要作用是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确的衔接。
	
2，目标文件的秘密
	各个段没有具体的起始地址，只有段大小信息
	各个标识符没有实际地址，只有段中的相对地址
	段和标识符的实际地址需要链接器具体确定
	
3，链接器的工作内容
	将目标文件和库文件整合为最终的可执行文件
		合并各个目标文件中的段(.text, .data, .bss)
		确定各个段和段中标识符的最终地址(重定位)

4，问题
	main函数是第一个被调用执行的函数吗？
	
	默认情况下(gcc)
	(1) 程序加载后，_start()是第一个被调用执行的函数
	(2) _start()函数准备号参数后立即调用__libc_start_main()函数
	(3) __libc_start_main()初始化运行环境后调用main()函数执行
	_start()函数的入口地址就是代码段(.text)的起始地址！
	
	__libc_start_main()函数的作用
		调用__libc_csu_init()函数(完成必要的初始化操作)
		启动程序的第一个线程(主线程)，main()为线程入口
		注册__libc_csu_fini()函数(程序运行终止时被调用)
	
	程序的启动过程
	_start -> __libc_start_main -> __libc_csu_init -> _init 
	-> __do_global_ctors_aux -> main -> ...
	
5，自定义函数入口地址
	gcc提供-e选项用于在链接时指定入口地址
	自定义入口函数时必须使用-nostartfiles选项进行链接
	gcc -e program -nostartfiles program.o -o program.out

第8课 揭开链接器的面纱-中
1，链接脚本的概念和意义
	链接脚本用于描述链接器处理目标文件和库文件的方式
		合并各个目标文件中的段
		重定位各个段的起始地址
		重定位各个符号的最终地址
		
2，链接脚本的本质
			 链接脚本
	main.o     \|/
	libc.a -> 链接器 -> 可执行程序
	func.o
		
3，链接脚本初探
	SECTIONS				# 关键字，描述各个段在内存中的布局
	{
		.text 0x20000000:	# 代码段起始地址(将.text重定位到0x20000000)
		{
			*(.text)		# 所有目标文件中的代码段合并进入可执行程序
		}
		
		. = 0x80000000;		# 设置当前地址 (. 在链接脚本中指当前位置指针)
		
		S = .;				# 设置标识符 S 的存储地址 (重定位标识符S)
		
		.data 0x30000000:
		{
			*(.data)
		}
		
		.bss :
		{
			*(.bss)
		}
	}
	
4，注意事项
	各个段的链接地址必须符合具体平台的规范
	链接脚本能够直接定义标识符并指定存储地址
	链接脚本中能够指定源代码中标识符的存储地址
	在Linux中，进程代码段(.text)的合法起始地址为[0x08048000,0x08049000]
	
	默认情况下
		链接器认为程序应该加载进入同一个存储空间
	嵌入式系统中	
		如果存在多个存储空间，必须使用MEMORY进行存储区域定义
	MEMORY命令的使用
		MEMORY
		{
			ROM0(WX) : ORIGIN = 0x02000000, LENGTH = 120K
			RAM0(!X) : ORIGIN = 0x04000000, LENGTH = 256K
		}
		SECTIONS
		{
			.text : { *(.text) } > ROM0
			.data : { *(.data) } > RAM0
			.bss  : { *(.bss)  } > RAM0
		}
	MEMORY命令的属性定义
		R	只读
		W	可读可写
		X	可执行
		A	可分配
		I	已初始化
		L	已初始化
		!	属性反转

5，ENTRY命令指定入口点
	ENTRY(entry)
	SECTIONS
	{
		.text : { *(.text) }
		.data : { *(.data) }
		.bss  : { *(.bss)  }
	}
	
第9课 汇编语言的嵌入编程
1，C语言中的内嵌汇编
	内嵌汇编的语法格式：
		asm volatile(	-- volatile可选，禁止编译器对汇编代码进行优化
			"汇编指令"	-- 汇编指令间用'\n'分隔
			:"=限制符"(输出参数)		-- 以下三行为可选参数，关联C语言和汇编指令
			:"限制符"(输入参数)
			:保留列表
		);
	示例：
		int main()
		{
			int result = 0;
			int input = 0;
			
			asm volatile(
				"movl %1, %0\n"
				: "=r"(result)	// 输出变量(与汇编交互) 
				: "r"(input)	// 输入变量(与汇编交互) 
			);
		}
	编译器做了什么？
		将result关联到某个适合的寄存器
		将input关联到另一个适合的寄存器
		通过通用寄存器间接操作变量
		asm volatile(
			"movl %1, %0\n"	// %1 -> input %0 -> result
			: "=r"(result)	
			: "r"(input));
		"r"用于指示编译器自动将通用寄存器关联到变量
		movl input, result
		这条指令错误，汇编语言不支持内存到内存的直接操作。
		
2，常用限制符的说明
	r	通用寄存器
	a	eax, ax, al
	b	ebx, bx, bl
	c	ecx, cx, cl
	d	edx, dx, dl
	S	esi, si
	D	edi, di
	q	寄存器a,b,c,d
	m	使用合法内存代表参数
	g	任意寄存器，内存，立即数
	
3，如何不通过printf打印实现打印输出？
	通过INT 80H使用内核服务
		INT指令用于使用Linux内核服务(中断指令)
		80H是一个中断向量号，用于执行系统调用
		
	如何指定具体的系统调用(如：sys_write)以及调用参数？
	通过寄存器指定具体的系统调用及参数
	
	INT 80H示例一：
	char* s = "Son, JingChi\n";
	int l = 13;
	
	asm volatile(
		"movl $4, %%eax\n"	// 指定编号为4的系统调用(sys_write)
		"movl $1, %%ebx\n"	// 指定sys_write的输出目标，1为标准输出
		"movl %0, %%ecx\n"	// 指定输出字符串地址
		"movl %1, %%edx\n"	// 指定输出字符串长度
		"int $0x80     \n"	// 执行系统调用
		:
		: "r"(s), "r"(l)
		: "eax", "ebx", "ecx", "edx");	// 保留寄存器，不用于关联变量
	
	INT 80H使用示例二
	asm volatile(
		"movl $1, %eax\n"		// 指定编号为1的系统调用sys_exit
		"movl $42, %ebx\n"	 	// 指定sys_exit的参数，即退出码
		"int $0x80     \n");	// 执行系统调用

注意事项
	嵌入汇编时，除汇编模板外，其余参数可以全部省略
	当省略的参数在中间时，对应分隔符":"不可省略
	当省略保留列表时，对应分隔符":"可省略
	当省略可选参数时，寄存器前使用单个%作为前缀
	当存在可选参数时，寄存器前使用两个%作为前缀
	
小结
	C程序中支持直接嵌入汇编语言进行编程
	通过寄存器到变量的关联完成汇编到C语言的交互
	内嵌汇编代码时，通过占位符指定交互的变量
	限制符指示编译器将合适的寄存器关联到变量
	通过内嵌汇编能够直接使用系统服务
	
第10课 揭开链接器的面纱-下
1，课程实验(模拟嵌入式开发)
	编写一个"体积受限"的可执行程序
	通过makefile完成代码编译
	运行后在屏幕打印字符串
	
	深度分析
	如何做到体积最小？ -> 独立于libc库进行编译 -> 编写链接脚本自定义入口函数
	-> 如何不依赖libc库进行打印 -> 直接使用系统调用 -> 如何使用系统调用
	-> 在C语言中嵌入汇编 -> ...
	
	解决方案
		通过内嵌汇编自定义打印函数和退出函数(INT 80H)
		通过链接脚本自定义入口函数(不依赖任何库和GCC内置功能)
		删除可执行程序中的无用信息(无用段信息，调试信息，等)
	
	最后的准备
		ld命令
			GNU的链接器，将目标文件链接为可执行程序
			GCC编译器集中的一员，重要的幕后工作者
		ld -static
			-static表示ld使用静态链接的方式来产生最终程序，
			而不是默认的动态链接方式
		gcc -fno-builtin
			-fno-builtin参数用于关闭GCC内置函数的功能
			gcc提供了很多内置函数(Built-in function), 他会把一些常用的C库函数
			替换成编译器的内置函数，已达到优化的目的。
			
第11课 调试器GDB-上
1，gdb
	能够跟踪程序的执行，也能恢复程序崩溃前的状态
	
2，gdb的常规应用
	自定义程序的启动方式(指定影响程序运行的参数)
	设置条件断点(在条件满足时暂停程序的执行)
	回溯检查导致程序异常结束的原因(Core Dump)
	动态改变程序执行流(定义问题的辅助方式)
	
3，gdb的启动方式
	直接启动
		gdb
		gdb test.out
		gdb test.out core
	动态连接
		gdb test.out pid
	
4,gdb应用示例一
		gdb						// 启动
	(gdb) file test.out			// 载入目标程序
	(gdb) set args arg1 arg2	// 设置命令行参数
	(gdb) run					// 执行目标程序
	
	示例二
		gdb				// 启动
	(gdb) attach pid	// 链接到目标程序，链接成功后目标进程将停止
	(gdb) continue		// 恢复执行
	
5，使用gdb进行断点调试
	断点类型
		软件断点：由非法指令异常实现(软件实现)
		硬件断点：由硬件特性实现(数量有限)
		数据断点：由硬件特性实现(数量有限)
	
	软件断点的相关操作
		通过函数名设置断点
			break func_name [ if var = value ]
			tbreak func_name [ if var = value ]
		通过文件名行号设置断点
			break file_name:line_num [ if var = value ]
			tbreak file_name:line_num [ if var = value ]
		break设置永久有效断点，tbreak设置一次有效断点
	
		断点查看			info breakpoints
		断点删除			delete 1 2 n
						delete breakpoints
		断点状态改变		enable 1 2 n
						enable breakpoints
						disable 1 2 n
						disable breakpoints

6，调试时的常用操作
	变量查看				print name
	变量设置				set var name=value
	执行下一行代码		next
	连续执行n行代码		next n
	执行进入函数			step
	强制当前函数返回		return [value]
	运行至当前函数返回	finish
	执行至目标行			until line
	跳转执行				jump line
	
7，硬件断点及其应用
	当代码位于只读存储器(flash)时，只能通过硬件断点调试
	硬件断点需要硬件支持，数量有限
	gdb中通过hbreak命令支持硬件断点
	hbreak与break使用方式完全一致

第12课 调试器gdb-下
1，数据断点
	gdb中支持数据断点的设置
	watch命令用于监视变量是否被改变(本质为硬件断点)
	watch命令的用法： watch var_name
	
2，gdb中的内存查看
	gdb中可以检查任意内存区域中的数据
	命令语法： x /Nuf expression
		N - 需要打印的单元数
		u - 每个单元的大小
		f - 数据打印格式
	示例： x /4bx 0x804a024
	
	x命令中参数 u 对应的单位
		b	单字节
		h	双字节
		w	四字节
		g	八字节
	
	gdb中的打印格式
		x	十六进制
		d	有符号十进制
		u	无符号十进制
		o	八进制
		t	二进制
		a	地址
		c	字符
		f	浮点数
		
3，函数调用栈的查看(backtrace和frame)
	backtrace
		查看函数调用的顺序(函数调用栈的信息)
	frame N
		切换到栈编号为N的上下文中
	info frame
		查看当前函数调用的栈帧信息
		
	什么时栈帧信息？
			参数
			返回地址
	ebp -->
			old ebp
			寄存器信息
			局部变量
			其它数据信息
	esp -->
	
4，深入info命令
	info registers	查看当前寄存器的值
	info args		查看当前函数参数的值
	info locals		查看当前局部变量的值
	info frame		查看当前栈帧的详细信息
	info variables	查看程序中的变量符号
	info functions	查看程序中的函数符号
	
5，一些调试中的小技巧
	断点处自动打印		display /f expression
						undisplay
	查看程序中的符号		whatis
						ptype
	gdb中的代码查看		list
						set listsize N
	gdb中的Shell操作		shell cmd
	
第13课 深入理解程序的结构
1，程序由不同的段构成(代码段，数据段)
	程序的静态特征就是指令和数据
	程序的动态特征就是执行指令处理数据

2，代码段(.text)
	源代码中的可执行语句编译后进如代码段
	代码段在内存管理单元的系统中具有只读属性
	代码段的大小在编译结束后就已经固定(不能动态改变)
	代码段中可以包含敞亮数据(如：常量字符串)

3，数据段(.data, .bss, .rodata)
	数据段用于存放源代码中具有全局生命期的变量
		.bss
			存储未初始化(初始化为0)的变量
		.data
			存储具有非0初始值的变量
		.rodata
			存储const关键字修饰的变量
			
	问题：同是全局变量和静态局部变量，为什么初始化和未初始化的保存在不同段中？
	
4，深入理解.data和.bss
	程序加载后
		.bss段中的所有内存单元被初始化为0
		将程序文件中.data段相关的初始值写入对应内存单元
		(.bss段中的变量不用在程序文件中保存初始值，从而减小可执行程序文件的体积，并且提高程序的加载效率)
		objdump -s -j .rodata test.out
		查看.rodata段存储的初始值
		
5，程序中的栈(stack)
	程序中的栈本质是一片连续内存空间
	SP寄存器作为栈顶“指针”实现入栈操作和出栈操作
	
6，栈的深入理解
	中断发生时，栈用于保存寄存器的值
	函数调用时，栈用于保存函数的活动记录(栈帧信息)
	并发编程时，每一个线程拥有自己独立的栈
	
7，程序中的堆(heap)
	堆是一片“闲置”的内存空间，用于提供动态内存分配
	堆空间的分配需要函数支持(malloc)
	堆空间在使用结束后需要归还(free)
	
8，内存映射段(Memory Mapping Segment)
	内核将硬盘文件的内容直接映射到内存映射段(mmap)
	动态链接库在可执行程序加载时映射到内存映射段
	程序执行时能够创建匿名映射区存放程序数据
	
	内存映射文件原理简介
		将硬盘上的文件数据逻辑映射到内存中(零耗时)
		通过缺页中断进行文件数据的实际载入(一次数据拷贝)
		映射后的内存的读写就是对文件数据的读写
		
第14课 缔造程序兼容的合约-上
1，什么是ABI(Application Binary Interface)
	应用程序二进制接口
		数据类型的大小、数据对齐方式
		函数调用发生时的调用约定
		系统调用的编号，以及进行系统调用的方式
		目标文件的二进制格式、程序库格式、等等

2，什么是EABI(Embedded Application Binary Interface)
	嵌入式应用程序二进制接口
		针对嵌入式平台的ABI规范
			可链接目标代码以及可执行文件格式的二进制规范
			编译连接工具的基础规范、函数调用规范、调用格式规范，等
			EABI与ABI的主要区别时应用程序代码中允许使用特权指令

3，广义上ABI的概念
	泛指应用程序在二进制层面应该遵循的规范
  狭义上ABI的概念
  	特指
  		某个具体硬件平台的ABI规范文档
  		某个具体操作系统平台的ABI规范文档
  		某个具体虚拟平台的ABI规范文档
  		
4，ABI规范示例
	为什么下面的代码能够以0为退出码结束程序运行？
		asm volatile (
			"movl $1, %eax\n"		// #1 -> sys_exit 
			"movl $0, %ebx\n"		// exit code
			"int $0x80	  \n");		// call sys_exit(0)
			
5，ABI和API有什么不同？
	ABI和API是不同层面的规范
		ABI是二进制层面的规范
		API是源代码层面的规范
	ABI和API没有直接联系
		遵循相同ABI的系统，所提供的API可能不同
		所提供API相同的系统，遵循的ABI可能不同
		
6，(1) ABI定义了基础数据类型的大小
	ABI vs 移植性
					应用程序逻辑层
					应用程序框架层
					
	平台改变时，		类型适配层
	只需要重定义 ->	(类型及大小不随平台而改变)
	类型适配层				
					基础类型及大小(ABI规范定义) <- 平台不同时，基础类型及大小可能不同
					
					硬件体系架构(CPU)
					
	(2) ABI定义了结构体/联合体的字节对齐方式
	(3) ABI定义了硬件寄存器的使用方式
		寄存器是处理器用来数据和运行程序的重要载体
		一些寄存器在处理器设计时就规定好了功能
			EIP(指令寄存器)，指向处理器下一条要执行的指令
			ESP(栈顶指针寄存器)，指向当前栈存储区的顶部
			EBP(栈帧基址寄存器)，指向函数栈帧的重要位置
			
	(4) 函数的调用约定
		当函数调用发生时
			参数会传递给被调用的函数
			而返回值会被返回给函数的调用者
		调用约定描述参数如何传递到栈中以及栈的维护方式
			参数传递顺序(如：从右向左进行参数的入栈)
			调用栈清理(如：被调函数负责清理栈)
		调用约定是ABI规范的一部分
		调用约定通常用于库调用和库开发的时候
		
小结
	广义上的ABI指应用程序在二进制层面需要遵守的约定
	狭义上的ABI指某一个具体硬件或者操作系统的规范文档
		ABI定义了基础数据类型的大小
		ABI定义了结构体/联合体的字节对齐方式
		ABI定义了硬件寄存器的使用方式
		ABI定义了函数调用时需要遵守的调用约定
		
第15课 缔造程序兼容的合约-下
1，ABI定义了函数调用时
	栈帧的内存布局
	栈帧的形成方式
	栈帧的销毁方式
	
	ebp是函数调用以及函数返回的核心寄存器
		ebp为当前栈帧的基准(存储上一个栈帧的ebp)
		通过ebp能够获取返回地址，参数，局部变量，等
				栈帧偏移			意义											|				
				ebp + 4(n+1)	存储第n个参数的值							|
		caller	ebp + 8			存储第一个参数的值(上一个esp所指向的位置)		|
		--------------------------------------------------					|
				ebp + 4			存储函数返回的地址							|
		callee	ebp				存储上一个栈帧的ebp值						|
				ebp - 4			存储寄存器，局部变量，临时变量，等		   \|/
				
2，函数调用发生时的细节操作
	调用者通过call指令调用函数，将返回地址压入栈中
	函数所需要的栈空间大小由编译器确定，表现为字面常量
	函数结束时，leave指令恢复上一个栈帧的esp和ebp
	函数返回时，ret指令将返回地址恢复到eip(PC)寄存器
		leave <--> move ebp, esp
				   pop ebp
				   
		ret  <-->  pop eip
		
3，问题
	函数调用时，参数如何入栈？
	函数返回时，返回值在哪里？
	
	C语言默认使用的调用约定(__cdecl__)
		调用函数时，参数从右向左入栈
		函数返回时，函数的调用者负责将参数弹出栈
		函数返回值保存在eax寄存器中
	
	一些注意事项
		只有使用了__cdecl__的函数支持可变参数定义
		当类的成员函数为可变参数时，调用约定自动变为__cdecl__
		调用约定定义了函数被编译后对应的最终符号名

4，问题
	当返回值类型为结构体时，如何将值返回到调用函数中？
	
	结构体类型的返回值
		函数调用时，接收返回值的变量地址需要入栈
		被调函数直接通过变量地址拷贝返回值
		函数返回值用于初始化与赋值对应的过程不同
		
	函数返回值初始化变量
		struct ST st = f(1, 2);
		将局部变量st的地址传入栈中(调用者的栈中)
		
	函数返回值给变量赋值
		struct ST st = {0};
		st = f(1, 2);
		===>
		struct ST st = {0};
		struct ST {temp} = f(1, 2);
		st = {temp};
		将临时变量temp的地址传入栈中(被调者的栈中)
		
小结
	栈帧是函数调用时形成的链式内存结构
	ebp是构成栈帧的核心基准寄存器
	调用约定决定了函数调用时的细节行为
	基础数据类型的返回值通过eax传递
	结构体类型的返回值通过内存拷贝完成
	
第16课 混淆指针和数组的问题
1，再论指针和数组
	指针
		本质为变量，保存的目标值为内存地址
		指针运算与 * 操作符配合使用能够模拟数组行为
	数组
		数组是一段连续的内存空间
		数组名可看做指向数据第一个元素的常量指针
		
	在C语言层面中的等价关系
		int a[3] = {0};
		int* p = a;
		p[0] = 1;	// a[0] = 1;
		p[1] = 2;	// a[1] = 2;
		a[2] = 3;	// p[2] = 3;

2，问题
	在二进制层面，数组和指针是否等价？看反汇编代码
	结论
		指针与数据在二进制层面的操作完全不同
		指针操作：先寻址，再对地址单元进行操作
		数据操作：直接针对地址单元进行操作

	C/C++编译器的天生缺陷
		由4个子部件组成(预处理器，预编译器，汇编器，链接器)
		每个子部件独立工作，相互之间没有通信
		语法规范只在编译阶段有效(如：类型约束，保护成员)
		编译器部件对各个源文件进行独立编译(认为源文件相互独立)
		
	问题本质
				根据当前源代码产生二进制代码
		file.c  ----------------------------> file.o 目标文件中的符号无类型信息
				如：当前源码中声明的指针，按照
				指针方式编译
							\|/
				链接器最终确定各个符号的地址
				
	解决方案
		尽可能不使用跨文件的全局变量(非static全局变量)
		当必须使用时，在统一固定的头文件中声明(global.h)
		使用跨文件全局变量的源文件直接包含global.h
		定义跨文件全局变量的源文件也需要包含global.h
		
	小贴士：声明和定义不同
		声明只是告诉编译器，目标存在，可使用
		定义实际为目标分配内存(变量)或确定执行流(函数)
		理论上，任何目标都需要先声明，再使用
		C/C++语言允许声明与定义的统一
		
第17课 volatile，让我保持原样
1，问题分析
	编译器优化时，编译器根据当前文件进行优化
	编译器能够发现变量“不可能”被改变(const全局变量)
	为了效率上的提高，编译器将变量值进行缓存
	缓存的方式为：把变量值从内存中读取进入寄存器
	每次访问变量时直接从寄存器读取对应值
	
	解决方案
		使用volatile修饰可能被意外修改的变量(内存)
			volatile修饰的变量是一种易变的变量
			volatile可理解为“编译器警告指示字”
			volatile告诉编译器必须每次去内存中取变量值
			
2，问题
	如何理解const和volatile同时修饰变量？
	在语义上是否矛盾？
	
	const和volatile
		const表示修饰的变量不能出现在赋值符号左边(编译阶段当前文件起作用)
		volatile表示使用变量时直接从内存取值
		const和volatile同时修饰变量时互不影响其含义
		
小结
	编译优化时，编译器只根据当前文件进行优化
	编译器的优化策略可能造成一些“意外”
	volatile强制编译器必须每次从内存中取变量值
	const和volatile同时修饰变量时互不影响其含义
	
第18课 设计，软件质量之本-上
1，软件设计的特点
	软件设计是一个塑造模型(概念)的过程
	软件设计是一个取舍的过程
	软件设计是一个分而治之的过程
	软件设计是一个在理性范围内追求完美的过程
	
2，什么是软件质量？
	用户角度
		defect和bug的数量越少意味着质量越好
	开发角度
		整体架构设计易于扩展
		模块之间耦合性低，易于复用
		代码简洁易懂，易于维护

3，如何提高软件质量？
	编码前，架构设计质量必须得到保证
	编码时，代码质量必须得到保证
	编码后，测试质量必须得到保证
	
第19课 设计，软件质量之本-中
1，设计原则-1：以人为本
	核心：将显示世界直接映射到软件世界
	意图：便于沟通和理解，降低复杂性，增加维护性
	要点：使用现实世界中的概念
	
2，设计原则-2：简单即是美
	核心：用最简单的方法描述解决方案
	意图：便于沟通和理解，降低复杂性，增加维护性
	要点：使用团队熟悉的技术进行设计
	
3，设计原则-3：让模块善始善终
	核心：模块的初始化与模块的终止同等重要
	意图：确保模块状态的恢复和保存
	要点：对称设计
	
4，设计原则-4：重视运行时数据的收集
	核心：考虑程序运行状态数据的收集模块
	意图：监控程序运行状态，便于调试与测试

第20课 设计，软件质量之本-下
1，设计原则-5：代码自注释
	核心：代码自身就能够很好的进行功能性说明
	意图：便于沟通和理解，增加维护性
	
2，代码质量
	最终的产品代码应该“非常容易”读懂
	注释作为补充说明必不可少，但不是越多越好
	注释应该起到画龙点睛的作用，用于简要的描述代码意图；
	避免使用注释描述程序的运行流程。
	
3，设计原则-6：通过机制解决问题
	核心：考虑当前设计是否存在“漏洞”
	意图：杜绝类似问题的再次发生
	
4，架构经验
	设计不是一次性完成的，需要根据实际问题进行重构
	
5，设计原则-7：防御性程序设计
	核心：防止他人的“意外”错误
	意图：提高代码鲁棒性
	
第21课 系统模块管理的设计
1，系统模块化设计
	将系统中有关联的部分组合在一起，构成具有特定功能的子系统
	模块的内部组成具有较强的耦合性，模块本身具有一定通用性
	不同的模块间可以进行相互组合与依赖，进而构成不同的产品
	
2，模块间的分层
	硬件层，系统层，平台层，框架层，应用层
	
	模块的分级(更细的设计粒度)
		同一层中的模块根据依赖关系能够继续分级
	
	分层与分级的意义
		模块间的依赖关系决定了初始化的前后顺序
		被依赖的模块必须先初始化(底层先于上层初始化)
		
3，实现要点
	每一个模块对应一个ID和结构体变量(module_init_t)
	模块需要注册后才能被初始化(module_register)
	模块提供一个回调函数(module_callback_t)用于接收事件
	所有的模块根据层级关系组织于不同链表中
		同一个链表中的模块没有依赖关系
		整个系统从最底层(最上层)的模块开始进行初始化(销毁)

