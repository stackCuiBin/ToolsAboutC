第1课 深入浅出处理器-上
1，处理器：微控制器 VS 微处理器
	微控制器
		CPU + 片内内存 + 片内外设
	微处理器
		CPU
注意：
	为控制器具有成本低，功耗低等优点，常用于嵌入式系统设计
	对于软件工程师而言，微控制器和微处理器没有任何区别

2，寄存器的分类
	CPU寄存器
		专用指令执行，数据运算，变量处理，参数传递
	外设寄存器
		用于控制外设的行为和工作方式
		寄存器值的配置需要根据芯片手册完成

3，处理器中的关键寄存器
	PC-程序计数器(指令指针IP)
		每执行一条指令，PC中的值就会发生变化
		PC始终保存下一条CPU要执行的指令地址
	SP-栈指针(Stack Pointer)
		始终指向栈空间的顶端，实现LIFO特性
		保存中断断点，保存函数调用的返回点，保存CPU现场数据，等
		
4，处理器的IO操作
	处理器与外设之间的数据通信通过IO操作完成
	内存映射IO空间
		外设通过精密的硬件连接映射到处理器的地址空间
		通过地址访问的方式与外设进行通信
	独立IO空间
		独立于地址空间，无法通过地址访问外设
		使用专用指令与外设进行通信
	操作外设的基本方式
		通过IO端口配置控制寄存器
		通过IO端口读取数据寄存器
(从软件工程师的角度来看，只需要对不同的IO端口读写就可以操作外设；读写IO端口
时候的具体值和意义需要查询具体的硬件手册)

5，处理器的启动过程简介
	处理器上电后，PC寄存器固化了一个默认值
	PC默认值用于决定第一条执行指令
	第一条执行指令隶属于启动程序
	
6，启动程序(Bootloader)
	系统上电后运行的第一个程序(not OS)
	根据运行阶段，体积和功能的不同分为三个部分
		BL0-固化于硬件中，用于初始化硬件，加载并运行BL1
		BL1-存储于外部存储设备中，用于初始化主存，加载并运行BL2
		BL2-存储于外部存储设备中，用于引导操作系统执行
		
第2课 深入浅出处理器-中
1，中断的概念和意义
	中断是一种处理器与外设进行通信的机制
	用于“通知”处理器外部有“重要事件”发生
	一般情况下，中断需要被处理器响应

2，中断服务程序(ISR)
	从外设中读取中断状态寄存器的值，以便了解中断类型
	根据中断类型具体设计处理逻辑
	清除外设状态寄存器中的中断标志位
	清除处理器中的中断标志位
	
3，软件工程师眼中的中断服务程序
	不能有返回值，不能有参数传递
	必须短小而高效，避免浮点运算
	
4，中断的意义
	应用程序不必关心中断的发生与处理
	中断服务程序不必关心应用程序的执行状态
	中断是“上层应用”与“底层代码”的“分割界限”

5，中断的类型
	硬中断
		通过处理器中断信号线产生的中断
	软中断
		通过非法指令或者特殊指令触发的中断

6，中断的优先级
	多个中断同时出现时，处理器先响应高优先级的中断
	低优先级中断的ISR执行时，可以被高优先级中断再次打断
	ISR比APP Code拥有更高的执行优先级
	
7，中断的应用-程序断点
	断点指的是调试工具用于暂停代码执行的指令位置
	断点的实现原理为处理器的中断支持
		软件断点：利用非法指令异常产生中断实现
		硬件断点：利用中断寄存器的特性产生中断实现
		
8，程序断点的实现原理
	获取原程序指定行对应的代码地址
	把代码地址中的指令替换为中断触发指令
	在中断服务程序中将控制权交给调试程序
	调试程序读写源程序上下文信息
	调试程序将代码地址中的指令还原
	原程序从断点处继续向下执行
	
9，一个工程产品案例的剖析
	背景
		嵌入式实时系统对时序的要求比较严格
		各个线程的执行有相对严格的时间要求
	痛点
		断点调试在嵌入式实时系统中不适用
	
	常规解决方案-日志调试法
		在代码中的“关键位置”添加打印语句
		打印语句尽可能详细的打印上下文信息(函数名，局部变量，等)
		当系统出现问题时，查看日志文件，分析问题
	日志调试法存在的问题
		不易维护
			打印语句分散于产品代码的各个角落
		影响效率
			过多的打印语句意味着过多的IO操作，影响产品的整体执行效率
		分析困难
			当日志输出数量非常多的时候，很难精确定位问题
			也许只有添加打印语句的工程师看得懂日志输出
	一个想法
		同时结合日志调试法和断点调试法的优点，使得实时系统调试时，能够任意
		查看指定代码行上下文的信息；并且不增加打印语句，不暂停执行。
	解决方案
		获取原程序指定行对应的代码地址
		把代码地址中的指令替换为中断触发指令
		在中断服务程序中抓取全局信息和栈信息
		抓取的信息发送回调试程序并解析并输出
		
第3课 深入浅出处理器-下
1，内存管理单元(MMU)
	现代处理器中对内存进行高效管理的功能单元
	操作系统利用内存管理单元能够实现
		虚拟内存
		内存保护

2，经常被遗忘的事实
	应用程序开发时，面对的内存为虚拟内存
	虚拟内存模式下使用的内存地址为虚拟地址
	每一个进程拥有独立私有的虚拟地址空间
	(虚拟内存与实际物理内存无关，是一个假想的足够大的内存)
	
3，虚拟内存的意义
	虚拟内存能够支持多个大内存需求量的进程同时运行于较小的物理内存中。

4，虚拟内存的机制
	虚拟内存需要重新映射到物理内存
	虚拟地址映射到物理内存中的实地址
	每次只有进程的少量代码在物理内存中运行
	大部分进程代码位于存储器中
	
5，页式内存管理
	页时内存单位，指一定数量的内存(如：4K)
	虚拟内存和物理内存以页为单位管理
	进程的活动页被载入内存时，记录页地址的映射关系
	
	页式管理法将内存分为两个部分(p,d)
		p-地址高位，页面号
		d-地址低位，页内偏移量
	
第4课 深入浅出处理器-续
1，一个工艺上的问题
	处理器和内存所使用的半导体器件工艺不同
	工艺的差异导致了处理器与内存的速度差异
	数据处理时，处理器总是需要等待内存

2，程序访问的局部性
	短时间内，处理器访问的存储空间是一个很小的范围
		时间局部性
			某个存储单元在短时间内很可能被再次访问
		空间局部性
			某个存储单元的邻近单元在短时间内也被访问
			
3，高速缓冲存储器的引入(cache)
	cache是一种小容量高速存储器
	cache的存取速度与处理器的运算速度几乎同量级
	cache在现代计算机系统中直接内置于处理器芯片中
	
4，cache解决方案
	在处理器和内存之间设置cache
	把内存中被频繁访问的指令和数据复制到cache中
	大多数情况下，处理器能直接从cache中取得指令和数据

问题
	内存和cache之间如何映射？

5，直接映射法
	将cache和内存分成相同固定大小的块(如：512byte/块)
	内存中的每一块在cache中有固定的映射位置
	映射公式为
		POScache = 内存块号 % cache总块数
		
						0
				  |---->1
	flag0  0	  |		2
	flag1  1------		3
	flag2  2	  |		4
	flag3  3	  |---->5
	
	 cache			内存
	 特点：任意一个内存地址都能映射到cache中的一个固定位置
	 
	 内存地址划分
	 	标记    cache块号    块内地址
	 	t位       c位          b位
	 映射原理
	 	根据访问地址的中间c位找到cache中的对应块
	 	比较地址的高t位是否和cache flag相同
	 		相同：直接读取数据
	 		不同：从内存中复制块内容(更新cache的flag)
	 		
	直接映射法的特点
		优点：映射过程简单，所需耗时短
		缺点：当短时间内访问的地址有同余冲突时，会造成缓存失效

第5课 嵌入式C语言编译器
1，GCC和gcc有什么不同
	GCC( GNU Compiler Collection)
		GNU编译器集合，包含众多语言的编译器
		C，C++, Java, D, ...
	gcc
		特指GCC中的C语言编译器
		
2，GCC VS 嵌入式
	多数嵌入式操作系统都基于GCC进行源码编译
		Linux，VxWorks，Android，...
	实际开发中的使用
		内核开发：gcc
		应用开发：gcc/g++/gdc

3，什么是交叉编译？
	背景
		嵌入式设备往往资源受限
		不肯能在嵌入式上直接对处理器进行编程
	解决方案
		在开发主机(PC)上对源码进行编译
		最终生成目标主机(嵌入式设备)的可执行程序

4，gcc是如何进行交叉编译的？
	配置目标主机的编译工具链(如：arm-linux)
	配置工具链的具体版本
		根据具体的目标代码选择相应的工具链版本
		正确使用关于体系结构的特殊编译选项
		
5，初识编译器
	编译器：预处理器，编译器，汇编器，链接器
	file.c
			预处理器 -> file.i -> 编译器 -> file.s -> 汇编器 -> file.o
	file.h
	
6，如何理解"多语言混合开发"?
	开发方式一
	X语言
	Y语言 -> 目标平台汇编语言 -> 目标平台汇编器 -> 可执行程序
	Z语言
	
	开发方式二
	X语言 -> x.dll
	Y语言 -> y.a    目标平台链接器 -> 可执行程序
	Z语言 -> z.dll
	
	开发方式三
	X语言 -> x.exe
	Y语言 -> y.exe  进程间通信协议 -> 可执行程序
	Z语言 -> z.exe
	
7，gcc关键编译选项一
	预处理指令
		gcc -E file.c -o file.i
	编译指令
		gcc -S file.i -o file.s
	汇编指令
		gcc -c file.s -o file.o
	
	gcc关键编译选项二
	生成映射文件
		gcc -Wl,-Map=test.map file.c
	宏定义
		gcc -D'TEST="test"' file.c
	获取系统头文件路径
		gcc -v file.c
		
	gcc关键编译选项三
	生成依赖关系
		获取目标的完整依赖关系
			gcc -M test.c
		获取目标的部分依赖关系
			gcc -MM test.c
			
	gcc关键编译选项四
	指定库文件及库文件搜索路径
		-L选项：指定库文件的搜索路径
		-l选项：指定库文件
			gcc test.c -L. -lfunc
	
第6课
1，什么是开发环境？
	构建环境
		代码编写，程序编译，版本控制
	调试环境
		用于定位问题的辅助工具集
	测试环境
		用于验证目标程序是否满足用户的显性需求和隐性需求

2，GNU为GCC编译器提供了配套的辅助工具集(binutils)
	工具名		功能简介
	addr2line	将代码地址转换为对应的程序行号
	strip		剔除可执行程序中的调试信息
	ar			将目标文件打包成为静态库
	nm			列出目标文件中的符号及对应地址
	objdump		查看程序段信息及反汇编
	size		查看目标文件中的段大小
	strings		查看目标文件中的字符串
	
	addr2line	
		将指定地址转换为对应的文件名和行号
		常用于分析和定位内存访问错误的问题
	示例：定位0地址访问
		开启core dump选项
			ulimit -c unlimited
		运行程序，并生成奔溃时的core文件
			执行导致程序崩溃的测试用例
		读取core文件，获取IP寄存器的值(0x08048000)
			dmesg core
		使用addr2line定位代码行
			addr2line 0x08048000 -f -e test.out
			
	strip
		剔除程序文件中的调试信息，减少目标程序的大小
		一般在程序发布前都需要将调试信息剔除
		过多的调试信息可能影响程序的执行效率
		strip test.out

注意事项
	几乎所有的调试辅助工具都依赖于目标文件中的调试信息
	调试信息的运用能够快速定位问题
	使用gcc编译程序时使用-g选项生成调试信息
	发布程序时再考虑是否使用strip剔除调试信息
	
	ar
		打包目标文件
			ar crs libname.a x.o y.o
		解压目标文件
			ar x libname.a
			
	nm
		列出目标文件中的标识符(变量名，函数名)
		输出结果由三部分组成：{地址，段，标识符}
		示例： 08048430        T            func
		  标识符对应的地址   位于代码段   标识符的名字
	段标识说明
	A		地址值子啊链接过程中不会发生改变
	B或b		标识符位于未初始化数据段(.bss)
	C		未定义存储段的标识符，连接时决定段位置
	D或d		标识符位于数据段(.data)
	N		调试专用标识符
	R或r		标识符位于只读存储区(.rdata)
	T或t		标识符位于代码段(.text)
	U		未定义的标识符
	
	objdump
		反汇编目标文件，查看汇编到源码的映射
			objdump -d func.o
			objdump -S func.o
		查看目标文件中的详细段信息
			objdump -h test.out
	objdump -h的输出说明
		idx			段下标
		Name		段标识符(名字)
		Size		段所占空间的大小
		VMA			段起始地址的虚存地址
		LMA			段所在存储空间中的加载地址
		File off	段在目标文件中的相对位置
		Algn		段的边界对齐字节数
		
	size
		获取目标文件中的所有段大小
			size test.out
	
	strings
		获取目标文件中的所有字符串常量
			strings test.out
	
第7课 揭开链接器的面纱-上
1，链接器的意义
	链接器的主要作用是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确的衔接。
	
2，目标文件的秘密
	各个段没有具体的起始地址，只有段大小信息
	各个标识符没有实际地址，只有段中的相对地址
	段和标识符的实际地址需要链接器具体确定
	
3，链接器的工作内容
	将目标文件和库文件整合为最终的可执行文件
		合并各个目标文件中的段(.text, .data, .bss)
		确定各个段和段中标识符的最终地址(重定位)

4，问题
	main函数是第一个被调用执行的函数吗？
	
	默认情况下(gcc)
	(1) 程序加载后，_start()是第一个被调用执行的函数
	(2) _start()函数准备号参数后立即调用__libc_start_main()函数
	(3) __libc_start_main()初始化运行环境后调用main()函数执行
	_start()函数的入口地址就是代码段(.text)的起始地址！
	
	__libc_start_main()函数的作用
		调用__libc_csu_init()函数(完成必要的初始化操作)
		启动程序的第一个线程(主线程)，main()为线程入口
		注册__libc_csu_fini()函数(程序运行终止时被调用)
	
	程序的启动过程
	_start -> __libc_start_main -> __libc_csu_init -> _init 
	-> __do_global_ctors_aux -> main -> ...
	
5，自定义函数入口地址
	gcc提供-e选项用于在链接时指定入口地址
	自定义入口函数时必须使用-nostartfiles选项进行链接
	gcc -e program -nostartfiles program.o -o program.out

第8课 揭开链接器的面纱-中
1，链接脚本的概念和意义
	链接脚本用于描述链接器处理目标文件和库文件的方式
		合并各个目标文件中的段
		重定位各个段的起始地址
		重定位各个符号的最终地址
		
2，链接脚本的本质
			 链接脚本
	main.o     \|/
	libc.a -> 链接器 -> 可执行程序
	func.o
		
3，链接脚本初探
	SECTIONS				# 关键字，描述各个段在内存中的布局
	{
		.text 0x20000000:	# 代码段起始地址(将.text重定位到0x20000000)
		{
			*(.text)		# 所有目标文件中的代码段合并进入可执行程序
		}
		
		. = 0x80000000;		# 设置当前地址 (. 在链接脚本中指当前位置指针)
		
		S = .;				# 设置标识符 S 的存储地址 (重定位标识符S)
		
		.data 0x30000000:
		{
			*(.data)
		}
		
		.bss :
		{
			*(.bss)
		}
	}
	
4，注意事项
	各个段的链接地址必须符合具体平台的规范
	链接脚本能够直接定义标识符并指定存储地址
	链接脚本中能够指定源代码中标识符的存储地址
	在Linux中，进程代码段(.text)的合法起始地址为[0x08048000,0x08049000]
	
	默认情况下
		链接器认为程序应该加载进入同一个存储空间
	嵌入式系统中	
		如果存在多个存储空间，必须使用MEMORY进行存储区域定义
	MEMORY命令的使用
		MEMORY
		{
			ROM0(WX) : ORIGIN = 0x02000000, LENGTH = 120K
			RAM0(!X) : ORIGIN = 0x04000000, LENGTH = 256K
		}
		SECTIONS
		{
			.text : { *(.text) } > ROM0
			.data : { *(.data) } > RAM0
			.bss  : { *(.bss)  } > RAM0
		}
	MEMORY命令的属性定义
		R	只读
		W	可读可写
		X	可执行
		A	可分配
		I	已初始化
		L	已初始化
		!	属性反转

5，ENTRY命令指定入口点
	ENTRY(entry)
	SECTIONS
	{
		.text : { *(.text) }
		.data : { *(.data) }
		.bss  : { *(.bss)  }
	}
	
